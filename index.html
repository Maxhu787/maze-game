<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        #gameContainer {
            position: relative;
            background-color: white;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px;
        }

        #mazeCanvas {
            display: block;
            border: 1px solid #ccc;
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        #restartBtn {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #restartBtn:hover {
            background-color: #45a049;
        }

        #instructions {
            margin-top: 15px;
            color: #666;
            text-align: center;
        }

        /* Question Modal */
        #questionModal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #questionContent {
            background-color: white;
            margin: 10% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #questionText {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .option {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background-color: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        .option:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }

        .option.correct {
            background-color: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .option.incorrect {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        #feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
        }

        #feedback.correct {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        #feedback.incorrect {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        #continueBtn {
            display: none;
            margin-top: 15px;
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #continueBtn:hover {
            background-color: #0056b3;
        }

        #score {
            margin-top: 10px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>Maze Adventure Game</h1>
    
    <div id="gameContainer">
        <canvas id="mazeCanvas" width="600" height="600"></canvas>
    </div>
    
    <div id="score">Questions Answered: 0</div>
    
    <div id="controls">
        <button id="restartBtn">Restart Game</button>
    </div>
    
    <div id="instructions">
        Use arrow keys to move the blue dot from START (green) to END (red).<br>
        Collect the red question points to answer trivia questions along the way!
    </div>

     Question Modal 
    <div id="questionModal">
        <div id="questionContent">
            <div id="questionText"></div>
            <button class="option" data-index="0"></button>
            <button class="option" data-index="1"></button>
            <button class="option" data-index="2"></button>
            <button class="option" data-index="3"></button>
            <div id="feedback"></div>
            <button id="continueBtn">Continue</button>
        </div>
    </div>

    <script>
        // Game questions in JSON format
        const questions = [
            {
                question: "What is the capital of France?",
                options: ["London", "Berlin", "Paris", "Madrid"],
                correct: 2
            },
            {
                question: "Which planet is known as the Red Planet?",
                options: ["Venus", "Mars", "Jupiter", "Saturn"],
                correct: 1
            },
            {
                question: "What is 2 + 2?",
                options: ["3", "4", "5", "6"],
                correct: 1
            },
            {
                question: "Who painted the Mona Lisa?",
                options: ["Van Gogh", "Picasso", "Leonardo da Vinci", "Michelangelo"],
                correct: 2
            },
            {
                question: "What is the largest ocean on Earth?",
                options: ["Atlantic", "Indian", "Arctic", "Pacific"],
                correct: 3
            },
            {
                question: "Which programming language is known for web development?",
                options: ["Python", "JavaScript", "C++", "Java"],
                correct: 1
            },
            {
                question: "What year did World War II end?",
                options: ["1944", "1945", "1946", "1947"],
                correct: 1
            },
            {
                question: "Which element has the chemical symbol 'O'?",
                options: ["Gold", "Silver", "Oxygen", "Iron"],
                correct: 2
            }
        ];

        class MazeGame {
            constructor() {
                this.canvas = document.getElementById('mazeCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Calculate optimal cell size to fill canvas evenly
                this.cols = 29; // Odd number for proper maze generation
                this.rows = 29; // Odd number for proper maze generation
                this.cellSize = Math.min(
                    Math.floor(this.canvas.width / this.cols),
                    Math.floor(this.canvas.height / this.rows)
                );
                
                // Adjust canvas size to fit perfectly
                this.canvas.width = this.cols * this.cellSize;
                this.canvas.height = this.rows * this.cellSize;
                
                this.player = { x: 1, y: 1 };
                this.questionPoints = [];
                this.answeredQuestions = new Set();
                this.score = 0;
                
                this.maze = [];
                this.currentQuestion = null;
                
                this.keysPressed = {};
                this.lastMoveTime = 0;
                this.moveDelay = 150; // Adjust this value to make movement faster (lower) or slower (higher)

                this.initializeGame();
                this.setupEventListeners();
            }

            initializeGame() {
                this.generateMaze();
                this.placeQuestionPoints();
                this.player = { x: 1, y: 1 };
                this.endPoint = { x: this.cols - 2, y: this.rows - 2 };
                this.answeredQuestions.clear();
                this.score = 0;
                this.gameWon = false;
                this.updateScore();
                this.draw();
            }

            generateMaze() {
                // Initialize maze with walls
                this.maze = Array(this.rows).fill().map(() => Array(this.cols).fill(1));
                
                // Recursive backtracking maze generation
                const stack = [];
                const start = { x: 1, y: 1 };
                this.maze[start.y][start.x] = 0;
                stack.push(start);

                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = this.getUnvisitedNeighbors(current);

                    if (neighbors.length > 0) {
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Remove wall between current and next
                        const wallX = current.x + (next.x - current.x) / 2;
                        const wallY = current.y + (next.y - current.y) / 2;
                        this.maze[wallY][wallX] = 0;
                        this.maze[next.y][next.x] = 0;
                        
                        stack.push(next);
                    } else {
                        stack.pop();
                    }
                }
                
                // Ensure start and end points are always accessible
                this.maze[1][1] = 0; // Start point
                this.maze[this.rows - 2][this.cols - 2] = 0; // End point
                
                // Create a guaranteed path to end if needed
                this.ensurePathToEnd();
            }

            ensurePathToEnd() {
                // Simple path creation from start area to end area
                let x = 1, y = 1;
                const endX = this.cols - 2;
                const endY = this.rows - 2;
                
                // Create horizontal path
                while (x < endX) {
                    this.maze[y][x] = 0;
                    x += 2;
                    if (x < this.cols) this.maze[y][x] = 0;
                    x++;
                }
                
                // Create vertical path
                while (y < endY) {
                    this.maze[y][x - 1] = 0;
                    y += 2;
                    if (y < this.rows) this.maze[y][x - 1] = 0;
                    y++;
                }
                
                // Ensure end point connection
                this.maze[endY][endX] = 0;
                if (endX > 1) this.maze[endY][endX - 1] = 0;
                if (endY > 1) this.maze[endY - 1][endX] = 0;
            }

            getUnvisitedNeighbors(cell) {
                const neighbors = [];
                const directions = [
                    { x: 0, y: -2 }, // Up
                    { x: 2, y: 0 },  // Right
                    { x: 0, y: 2 },  // Down
                    { x: -2, y: 0 }  // Left
                ];

                for (const dir of directions) {
                    const newX = cell.x + dir.x;
                    const newY = cell.y + dir.y;

                    if (newX > 0 && newX < this.cols - 1 && 
                        newY > 0 && newY < this.rows - 1 && 
                        this.maze[newY][newX] === 1) {
                        neighbors.push({ x: newX, y: newY });
                    }
                }

                return neighbors;
            }

            placeQuestionPoints() {
                this.questionPoints = [];
                const numQuestions = Math.min(5, questions.length);
                
                for (let i = 0; i < numQuestions; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * (this.cols - 2)) + 1;
                        y = Math.floor(Math.random() * (this.rows - 2)) + 1;
                    } while (this.maze[y][x] === 1 || 
                             (x === 1 && y === 1) || // Start point
                             (x === this.cols - 2 && y === this.rows - 2) || // End point
                             this.questionPoints.some(p => p.x === x && p.y === y));
                    
                    this.questionPoints.push({ 
                        x, 
                        y, 
                        questionIndex: Math.floor(Math.random() * questions.length)
                    });
                }
            }

            setupEventListeners() {
                // Track which keys are currently pressed
                this.keysPressed = {};
                
                document.addEventListener('keydown', (e) => {
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                        this.keysPressed[e.key] = true;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                        this.keysPressed[e.key] = false;
                    }
                });

                // Game loop for responsive movement
                this.lastMoveTime = 0;
                this.moveDelay = 150; // Milliseconds between moves (adjust for speed)
                
                const gameLoop = (currentTime) => {
                    if (document.getElementById('questionModal').style.display === 'block') {
                        requestAnimationFrame(gameLoop);
                        return; // Don't move while question is showing
                    }
                    
                    // Check if enough time has passed since last move
                    if (currentTime - this.lastMoveTime > this.moveDelay) {
                        let moved = false;
                        let newX = this.player.x;
                        let newY = this.player.y;

                        if (this.keysPressed['ArrowUp']) {
                            newY--;
                            moved = true;
                        } else if (this.keysPressed['ArrowDown']) {
                            newY++;
                            moved = true;
                        } else if (this.keysPressed['ArrowLeft']) {
                            newX--;
                            moved = true;
                        } else if (this.keysPressed['ArrowRight']) {
                            newX++;
                            moved = true;
                        }

                        if (moved && this.isValidMove(newX, newY)) {
                            this.player.x = newX;
                            this.player.y = newY;
                            this.checkQuestionPoint();
                            this.checkWinCondition();
                            this.draw();
                            this.lastMoveTime = currentTime;
                        }
                    }
                    
                    requestAnimationFrame(gameLoop);
                };
                
                requestAnimationFrame(gameLoop);

                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.initializeGame();
                });

                // Question modal event listeners
                const options = document.querySelectorAll('.option');
                options.forEach(option => {
                    option.addEventListener('click', (e) => {
                        this.handleAnswer(parseInt(e.target.dataset.index));
                    });
                });

                document.getElementById('continueBtn').addEventListener('click', () => {
                    this.closeQuestionModal();
                });
            }

            checkWinCondition() {
                if (this.player.x === this.endPoint.x && this.player.y === this.endPoint.y && !this.gameWon) {
                    this.gameWon = true;
                    setTimeout(() => {
                        alert(`Congratulations! You completed the maze!\nQuestions answered correctly: ${this.score}`);
                    }, 100);
                }
            }

            isValidMove(x, y) {
                return x >= 0 && x < this.cols && y >= 0 && y < this.rows && this.maze[y][x] === 0;
            }

            checkQuestionPoint() {
                const questionPoint = this.questionPoints.find(p => 
                    p.x === this.player.x && p.y === this.player.y && 
                    !this.answeredQuestions.has(`${p.x}-${p.y}`)
                );

                if (questionPoint) {
                    this.showQuestion(questionPoint);
                }
            }

            showQuestion(questionPoint) {
                this.currentQuestion = questionPoint;
                const question = questions[questionPoint.questionIndex];
                
                document.getElementById('questionText').textContent = question.question;
                
                const options = document.querySelectorAll('.option');
                options.forEach((option, index) => {
                    option.textContent = question.options[index];
                    option.className = 'option';
                    option.disabled = false;
                });

                document.getElementById('feedback').style.display = 'none';
                document.getElementById('continueBtn').style.display = 'none';
                document.getElementById('questionModal').style.display = 'block';
            }

            handleAnswer(selectedIndex) {
                const question = questions[this.currentQuestion.questionIndex];
                const options = document.querySelectorAll('.option');
                const feedback = document.getElementById('feedback');
                
                // Disable all options
                options.forEach(option => option.disabled = true);
                
                // Show correct/incorrect styling
                options.forEach((option, index) => {
                    if (index === question.correct) {
                        option.classList.add('correct');
                    } else if (index === selectedIndex && index !== question.correct) {
                        option.classList.add('incorrect');
                    }
                });

                // Show feedback
                if (selectedIndex === question.correct) {
                    feedback.textContent = 'Correct! Well done!';
                    feedback.className = 'correct';
                    this.score++;
                } else {
                    feedback.textContent = `Incorrect. The correct answer was: ${question.options[question.correct]}`;
                    feedback.className = 'incorrect';
                }

                feedback.style.display = 'block';
                document.getElementById('continueBtn').style.display = 'block';
                
                // Mark question as answered
                this.answeredQuestions.add(`${this.currentQuestion.x}-${this.currentQuestion.y}`);
                this.updateScore();
            }

            closeQuestionModal() {
                document.getElementById('questionModal').style.display = 'none';
                this.draw(); // Redraw to remove the question point
            }

            updateScore() {
                document.getElementById('score').textContent = `Questions Answered: ${this.score}`;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw maze
                this.ctx.fillStyle = '#333';
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.maze[y][x] === 1) {
                            this.ctx.fillRect(
                                x * this.cellSize, 
                                y * this.cellSize, 
                                this.cellSize, 
                                this.cellSize
                            );
                        }
                    }
                }

                // Draw start point (green square)
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(
                    1 * this.cellSize + 2, 
                    1 * this.cellSize + 2, 
                    this.cellSize - 4, 
                    this.cellSize - 4
                );
                
                // Draw "START" text
                this.ctx.fillStyle = '#000';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('START', 1 * this.cellSize + this.cellSize/2, 1 * this.cellSize + this.cellSize/2 + 3);

                // Draw end point (red square)
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(
                    this.endPoint.x * this.cellSize + 2, 
                    this.endPoint.y * this.cellSize + 2, 
                    this.cellSize - 4, 
                    this.cellSize - 4
                );
                
                // Draw "END" text
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('END', this.endPoint.x * this.cellSize + this.cellSize/2, this.endPoint.y * this.cellSize + this.cellSize/2 + 3);

                // Draw question points (only unanswered ones)
                this.ctx.fillStyle = '#ff4444';
                this.questionPoints.forEach(point => {
                    if (!this.answeredQuestions.has(`${point.x}-${point.y}`)) {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            point.x * this.cellSize + this.cellSize / 2,
                            point.y * this.cellSize + this.cellSize / 2,
                            this.cellSize / 3,
                            0,
                            2 * Math.PI
                        );
                        this.ctx.fill();
                    }
                });

                // Draw player (blue dot)
                this.ctx.fillStyle = '#4444ff';
                this.ctx.beginPath();
                this.ctx.arc(
                    this.player.x * this.cellSize + this.cellSize / 2,
                    this.player.y * this.cellSize + this.cellSize / 2,
                    this.cellSize / 3,
                    0,
                    2 * Math.PI
                );
                this.ctx.fill();
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new MazeGame();
        });
    </script>
</body>
</html>