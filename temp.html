<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Game</title>
    <style>
      :root {
        --main-bg: #010e19;
        --secondary-bg: #121b26;
        --secondary-bg-hover: #1d2a38;
        --main-text: #fff;
        --secondary-text: #aaaaaa;
        --thirdonary-text: #666;
        --primary: #3a80f6;
        --secondary: #92b9fc;
      }
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        height: 100vh;
        overflow: hidden;
      }

      h1 {
        color: var(--primary);
        margin: 0;
        padding: 10px 0;
        text-align: center;
        font-size: 2em;
        background-color: var(--main-bg);
        border-bottom: 2px solid #333;
      }

      #gameLayout {
        display: flex;
        height: calc(100vh - 60px); /* Subtract header height */
      }

      #leftPanel {
        width: 280px;
        background-color: var(--main-bg);
        border-right: 2px solid #333;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        overflow-y: auto;
      }

      #gameContainer {
        flex: 1;
        background-color: var(--main-bg);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #mazeCanvas {
        display: block;
        border: 1px solid #ccc;
        margin-bottom: 8px;
        /* //! might break */
      }

      #rightPanel {
        width: 200px;
        background-color: var(--main-bg);
        border-left: 2px solid #333;
        padding: 20px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 20px;
      }

      #restartBtn {
        padding: 15px 25px;
        font-size: 18px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s;
        width: 100%;
      }

      #restartBtn:hover {
        background-color: #45a049;
      }

      #clearLeaderboardBtn {
        padding: 10px 20px;
        font-size: 14px;
        background-color: #dc3545;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.3s;
        width: 100%;
      }

      #clearLeaderboardBtn:hover {
        background-color: #c82333;
      }

      #instructions {
        color: #666;
        line-height: 1.5;
        font-size: 14px;
      }

      #score {
        font-size: 18px;
        font-weight: bold;
        background-color: var(--secondary-bg);
        color: var(--secondary-text);
        padding: 15px;
        border-radius: 8px;
        text-align: center;
      }

      #leaderboard {
        background-color: var(--secondary-bg);
        color: var(--secondary-text);
        border-radius: 8px;
        padding: 15px;
      }

      #leaderboard h3 {
        margin: 0 0 15px 0;
        color: var(--secondary-text);
        text-align: center;
        font-size: 18px;
      }

      .leaderboard-entry {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        margin: 5px 0;
        background-color: #fff;
        border-radius: 6px;
        border-left: 4px solid #007bff;
      }

      .leaderboard-entry.top-score {
        border-left-color: #ffd700;
        background-color: #fffbf0;
      }

      .leaderboard-entry .rank {
        font-weight: bold;
        color: #666;
        min-width: 25px;
      }

      .leaderboard-entry .name {
        flex: 1;
        margin: 0 10px;
        font-weight: 500;
      }

      .leaderboard-entry .score {
        font-weight: bold;
        color: #28a745;
      }

      .leaderboard-entry .time {
        font-size: 12px;
        color: #666;
        margin-left: 10px;
      }

      #gameStats {
        background-color: var(--secondary-bg);
        color: var(--thirdonary-text);
        border-radius: 8px;
        padding: 15px;
        font-size: 14px;
      }

      #gameStats h4 {
        margin: 0 0 10px 0;
        color: var(--secondary-text);
      }

      /* Question Modal */
      #questionModal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }

      #questionContent {
        background-color: white;
        margin: 10% auto;
        padding: 30px;
        border-radius: 10px;
        width: 80%;
        max-width: 500px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      #questionText {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 20px;
        color: #333;
      }

      .option {
        display: block;
        width: 100%;
        padding: 12px;
        margin: 8px 0;
        background-color: #f8f9fa;
        border: 2px solid #dee2e6;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s;
      }

      .option:hover {
        background-color: #e9ecef;
        border-color: #adb5bd;
      }

      .option.correct {
        background-color: #d4edda;
        border-color: #28a745;
        color: #155724;
      }

      .option.incorrect {
        background-color: #f8d7da;
        border-color: #dc3545;
        color: #721c24;
      }

      #feedback {
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
        font-weight: bold;
        text-align: center;
      }

      #feedback.correct {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      #feedback.incorrect {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      #continueBtn {
        display: none;
        margin-top: 15px;
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }

      #continueBtn:hover {
        background-color: #0056b3;
      }

      /* Name Input Modal */
      #nameModal {
        display: none;
        position: fixed;
        z-index: 1001;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
      }

      #nameContent {
        background-color: white;
        margin: 20% auto;
        padding: 30px;
        border-radius: 10px;
        width: 80%;
        max-width: 400px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        text-align: center;
      }

      #nameInput {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        border: 2px solid #dee2e6;
        border-radius: 6px;
        margin: 15px 0;
        box-sizing: border-box;
      }

      #submitNameBtn {
        padding: 12px 24px;
        font-size: 16px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      #submitNameBtn:hover {
        background-color: #218838;
      }
    </style>
  </head>
  <body>
    <!-- <h1>Maze Adventure Game</h1> -->
    <h1>Ëµ∞Ëø∑ÂÆÆÂõûÁ≠îÂïèÈ°å</h1>

    <div id="gameLayout">
      <div id="leftPanel">
        <div id="score">Questions Answered: 0</div>

        <div id="gameStats">
          <h4>Current Game</h4>
          <div>Time: <span id="gameTime">00:00</span></div>
          <div>Questions Remaining: <span id="questionsRemaining">5</span></div>
        </div>

        <div id="leaderboard">
          <h3>üèÜ Leaderboard</h3>
          <div id="leaderboardList">
            <div style="text-align: center; color: #666; font-style: italic">
              No scores yet!
            </div>
          </div>
        </div>

        <div id="instructions">
          <!-- <strong>How to Play:</strong><br><br>
                Use arrow keys to move the blue dot from START (green) to END (red).<br><br>
                Hold keys longer to move faster!<br><br>
                Collect the red question points to answer trivia questions along the way! -->
          <strong>ÈÅäÊà≤Ë™™ÊòéÔºö</strong><br /><br />
          ‰ΩøÁî®ÊñπÂêëÈçµÂ∞áËóçËâ≤ÈªûÂæûËµ∑ÈªûÔºàÁ∂†Ëâ≤ÔºâÁßªÂãïÂà∞ÁµÇÈªûÔºàÁ¥ÖËâ≤Ôºâ„ÄÇ<br /><br />
          Èï∑ÊåâÊñπÂêëÈçµÂèØ‰ª•Âä†Âø´ÁßªÂãïÈÄüÂ∫¶ÔºÅ<br /><br />
          Êî∂ÈõÜÁ¥ÖËâ≤ÂïèËôüÈªû‰ª•ÂõûÁ≠îÈÄî‰∏≠Âá∫ÁèæÁöÑÂïèÁ≠îÈ°åÔºÅ
        </div>
      </div>

      <div id="gameContainer">
        <canvas id="mazeCanvas"></canvas>
      </div>

      <div id="rightPanel">
        <button id="restartBtn">Restart Game</button>
        <button id="clearLeaderboardBtn">Clear Leaderboard</button>
      </div>
    </div>

    <!-- Question Modal -->
    <div id="questionModal">
      <div id="questionContent">
        <div id="questionText"></div>
        <button class="option" data-index="0"></button>
        <button class="option" data-index="1"></button>
        <button class="option" data-index="2"></button>
        <button class="option" data-index="3"></button>
        <div id="feedback"></div>
        <button id="continueBtn">Continue</button>
      </div>
    </div>

    <!-- Name Input Modal -->
    <div id="nameModal">
      <div id="nameContent">
        <h3>üéâ Congratulations!</h3>
        <p>You completed the maze!</p>
        <p>
          <strong>Score:</strong> <span id="finalScore"></span> questions
          correct
        </p>
        <p><strong>Time:</strong> <span id="finalTime"></span></p>
        <p>Enter your name for the leaderboard:</p>
        <input
          type="text"
          id="nameInput"
          placeholder="Enter your name"
          maxlength="20"
        />
        <br />
        <button id="submitNameBtn">Submit Score</button>
      </div>
    </div>

    <script>
      // Game questions in JSON format
      const questions = [
        {
          question: "What is the capital of France?",
          options: ["London", "Berlin", "Paris", "Madrid"],
          correct: 2,
        },
        {
          question: "Which planet is known as the Red Planet?",
          options: ["Venus", "Mars", "Jupiter", "Saturn"],
          correct: 1,
        },
        {
          question: "What is 2 + 2?",
          options: ["3", "4", "5", "6"],
          correct: 1,
        },
        {
          question: "Who painted the Mona Lisa?",
          options: ["Van Gogh", "Picasso", "Leonardo da Vinci", "Michelangelo"],
          correct: 2,
        },
        {
          question: "What is the largest ocean on Earth?",
          options: ["Atlantic", "Indian", "Arctic", "Pacific"],
          correct: 3,
        },
        {
          question: "Which programming language is known for web development?",
          options: ["Python", "JavaScript", "C++", "Java"],
          correct: 1,
        },
        {
          question: "What year did World War II end?",
          options: ["1944", "1945", "1946", "1947"],
          correct: 1,
        },
        {
          question: "Which element has the chemical symbol 'O'?",
          options: ["Gold", "Silver", "Oxygen", "Iron"],
          correct: 2,
        },
      ];

      class MazeGame {
        constructor() {
          this.canvas = document.getElementById("mazeCanvas");
          this.ctx = this.canvas.getContext("2d");

          // Calculate canvas size to fill available height
          const availableHeight = window.innerHeight - 60; // Subtract header height
          const availableWidth = window.innerWidth - 480; // Subtract left and right panels

          // Use the smaller dimension to keep maze square
          const size = Math.min(availableHeight - 40, availableWidth - 40); // Leave some padding

          this.canvas.width = size;
          this.canvas.height = size;

          // Calculate optimal cell size to fill canvas evenly
          this.cols = 29; // Odd number for proper maze generation
          this.rows = 29; // Odd number for proper maze generation
          this.cellSize = Math.floor(size / this.cols);

          // Adjust canvas size to fit perfectly
          this.canvas.width = this.cols * this.cellSize;
          this.canvas.height = this.rows * this.cellSize;

          // Color variables - easy to customize
          this.colors = {
            // mazeWalls: '#333',
            mazeWalls: "#fff",
            // player: '#4444ff',
            player: "#07a6f5",
            // questionPoints: '#ff4444',
            questionPoints: "#fff",
            // startPoint: '#00ff00',
            startPoint: "#00ff00",
            // endPoint: '#ff0000',
            endPoint: "#ff0000",
          };

          // Player positions - now using pixel coordinates for smooth movement
          this.player = {
            x: 1.5 * this.cellSize,
            y: 1.5 * this.cellSize,
          };
          this.playerRadius = this.cellSize / 3;
          this.moveSpeed = 4; // Pixels per frame - adjust for faster/slower movement

          this.questionPoints = [];
          this.answeredQuestions = new Set();
          this.score = 0;

          this.maze = [];
          this.currentQuestion = null;

          this.keysPressed = {};

          // Game timing
          this.startTime = null;
          this.gameTime = 0;
          this.gameTimer = null;

          this.initializeGame();
          this.setupEventListeners();
          this.loadLeaderboard();
        }

        initializeGame() {
          this.generateMaze();
          this.placeQuestionPoints();
          this.player = {
            x: 1.5 * this.cellSize,
            y: 1.5 * this.cellSize,
          };
          this.endPoint = {
            x: (this.cols - 1.5) * this.cellSize,
            y: (this.rows - 1.5) * this.cellSize,
          };
          this.answeredQuestions.clear();
          this.score = 0;
          this.gameWon = false;
          this.startTime = Date.now();
          this.gameTime = 0;

          // Start game timer
          if (this.gameTimer) clearInterval(this.gameTimer);
          this.gameTimer = setInterval(() => {
            this.gameTime = Date.now() - this.startTime;
            this.updateGameStats();
          }, 100);

          this.updateScore();
          this.updateGameStats();
          this.draw();
        }

        generateMaze() {
          // Initialize maze with walls
          this.maze = Array(this.rows)
            .fill()
            .map(() => Array(this.cols).fill(1));

          // Recursive backtracking maze generation
          const stack = [];
          const start = { x: 1, y: 1 };
          this.maze[start.y][start.x] = 0;
          stack.push(start);

          while (stack.length > 0) {
            const current = stack[stack.length - 1];
            const neighbors = this.getUnvisitedNeighbors(current);

            if (neighbors.length > 0) {
              const next =
                neighbors[Math.floor(Math.random() * neighbors.length)];

              // Remove wall between current and next
              const wallX = current.x + (next.x - current.x) / 2;
              const wallY = current.y + (next.y - current.y) / 2;
              this.maze[wallY][wallX] = 0;
              this.maze[next.y][next.x] = 0;

              stack.push(next);
            } else {
              stack.pop();
            }
          }

          // Ensure start and end points are always accessible
          this.maze[1][1] = 0; // Start point
          this.maze[this.rows - 2][this.cols - 2] = 0; // End point

          // Create a guaranteed path to end if needed
          this.ensurePathToEnd();
        }

        ensurePathToEnd() {
          // Simple path creation from start area to end area
          let x = 1,
            y = 1;
          const endX = this.cols - 2;
          const endY = this.rows - 2;

          // Create horizontal path
          while (x < endX) {
            this.maze[y][x] = 0;
            x += 2;
            if (x < this.cols) this.maze[y][x] = 0;
            x++;
          }

          // Create vertical path
          while (y < endY) {
            this.maze[y][x - 1] = 0;
            y += 2;
            if (y < this.rows) this.maze[y][x - 1] = 0;
            y++;
          }

          // Ensure end point connection
          this.maze[endY][endX] = 0;
          if (endX > 1) this.maze[endY][endX - 1] = 0;
          if (endY > 1) this.maze[endY - 1][endX] = 0;
        }

        getUnvisitedNeighbors(cell) {
          const neighbors = [];
          const directions = [
            { x: 0, y: -2 }, // Up
            { x: 2, y: 0 }, // Right
            { x: 0, y: 2 }, // Down
            { x: -2, y: 0 }, // Left
          ];

          for (const dir of directions) {
            const newX = cell.x + dir.x;
            const newY = cell.y + dir.y;

            if (
              newX > 0 &&
              newX < this.cols - 1 &&
              newY > 0 &&
              newY < this.rows - 1 &&
              this.maze[newY][newX] === 1
            ) {
              neighbors.push({ x: newX, y: newY });
            }
          }

          return neighbors;
        }

        placeQuestionPoints() {
          this.questionPoints = [];
          const numQuestions = Math.min(5, questions.length);

          for (let i = 0; i < numQuestions; i++) {
            let x, y;
            do {
              x = Math.floor(Math.random() * (this.cols - 2)) + 1;
              y = Math.floor(Math.random() * (this.rows - 2)) + 1;
            } while (
              this.maze[y][x] === 1 ||
              (x === 1 && y === 1) || // Start point
              (x === this.cols - 2 && y === this.rows - 2) || // End point
              this.questionPoints.some((p) => p.x === x && p.y === y)
            );

            this.questionPoints.push({
              x: (x + 0.5) * this.cellSize,
              y: (y + 0.5) * this.cellSize,
              questionIndex: Math.floor(Math.random() * questions.length),
            });
          }
        }

        // Check if a circular player can move to a position without hitting walls
        canMoveTo(x, y) {
          const radius = this.playerRadius;

          // Check the four corners of the player's bounding box
          const corners = [
            { x: x - radius, y: y - radius },
            { x: x + radius, y: y - radius },
            { x: x - radius, y: y + radius },
            { x: x + radius, y: y + radius },
          ];

          for (const corner of corners) {
            const gridX = Math.floor(corner.x / this.cellSize);
            const gridY = Math.floor(corner.y / this.cellSize);

            if (
              gridX < 0 ||
              gridX >= this.cols ||
              gridY < 0 ||
              gridY >= this.rows
            ) {
              return false;
            }

            if (this.maze[gridY][gridX] === 1) {
              return false;
            }
          }

          return true;
        }

        setupEventListeners() {
          // Track which keys are currently pressed
          this.keysPressed = {};

          document.addEventListener("keydown", (e) => {
            if (
              ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
                e.key
              )
            ) {
              e.preventDefault();
              this.keysPressed[e.key] = true;
            }
          });

          document.addEventListener("keyup", (e) => {
            if (
              ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
                e.key
              )
            ) {
              e.preventDefault();
              this.keysPressed[e.key] = false;
            }
          });

          // Game loop for smooth continuous movement
          const gameLoop = () => {
            if (
              document.getElementById("questionModal").style.display ===
                "block" ||
              document.getElementById("nameModal").style.display === "block"
            ) {
              requestAnimationFrame(gameLoop);
              return; // Don't move while modal is showing
            }

            let moved = false;
            let newX = this.player.x;
            let newY = this.player.y;

            // Handle continuous movement
            if (this.keysPressed["ArrowUp"]) {
              newY -= this.moveSpeed;
              moved = true;
            }
            if (this.keysPressed["ArrowDown"]) {
              newY += this.moveSpeed;
              moved = true;
            }
            if (this.keysPressed["ArrowLeft"]) {
              newX -= this.moveSpeed;
              moved = true;
            }
            if (this.keysPressed["ArrowRight"]) {
              newX += this.moveSpeed;
              moved = true;
            }

            // Check collision and update position
            if (moved) {
              // Check X movement
              if (this.canMoveTo(newX, this.player.y)) {
                this.player.x = newX;
              } else {
                newX = this.player.x; // Reset X if collision
              }

              // Check Y movement
              if (this.canMoveTo(this.player.x, newY)) {
                this.player.y = newY;
              }

              this.checkQuestionPoint();
              this.checkWinCondition();
              this.draw();
            }

            requestAnimationFrame(gameLoop);
          };

          requestAnimationFrame(gameLoop);

          document
            .getElementById("restartBtn")
            .addEventListener("click", () => {
              this.initializeGame();
            });

          document
            .getElementById("clearLeaderboardBtn")
            .addEventListener("click", () => {
              if (
                confirm(
                  "Are you sure you want to clear the leaderboard? This cannot be undone."
                )
              ) {
                localStorage.removeItem("mazeGameLeaderboard");
                this.loadLeaderboard();
              }
            });

          // Question modal event listeners
          const options = document.querySelectorAll(".option");
          options.forEach((option) => {
            option.addEventListener("click", (e) => {
              this.handleAnswer(parseInt(e.target.dataset.index));
            });
          });

          document
            .getElementById("continueBtn")
            .addEventListener("click", () => {
              this.closeQuestionModal();
            });

          // Name modal event listeners
          document
            .getElementById("submitNameBtn")
            .addEventListener("click", () => {
              this.submitScore();
            });

          document
            .getElementById("nameInput")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter") {
                this.submitScore();
              }
            });
        }

        checkWinCondition() {
          const distance = Math.sqrt(
            Math.pow(this.player.x - this.endPoint.x, 2) +
              Math.pow(this.player.y - this.endPoint.y, 2)
          );

          if (distance < this.cellSize / 2 && !this.gameWon) {
            this.gameWon = true;
            clearInterval(this.gameTimer);
            this.showNameModal();
          }
        }

        checkQuestionPoint() {
          this.questionPoints.forEach((point, index) => {
            if (this.answeredQuestions.has(index)) return;

            const distance = Math.sqrt(
              Math.pow(this.player.x - point.x, 2) +
                Math.pow(this.player.y - point.y, 2)
            );

            if (distance < this.cellSize / 2) {
              this.showQuestion(point, index);
            }
          });
        }

        showQuestion(questionPoint, pointIndex) {
          this.currentQuestionIndex = pointIndex;
          const question = questions[questionPoint.questionIndex];

          document.getElementById("questionText").textContent =
            question.question;

          const options = document.querySelectorAll(".option");
          options.forEach((option, index) => {
            option.textContent = question.options[index];
            option.className = "option";
            option.disabled = false;
          });

          document.getElementById("feedback").style.display = "none";
          document.getElementById("continueBtn").style.display = "none";
          document.getElementById("questionModal").style.display = "block";
        }

        handleAnswer(selectedIndex) {
          const questionPoint = this.questionPoints[this.currentQuestionIndex];
          const question = questions[questionPoint.questionIndex];
          const options = document.querySelectorAll(".option");
          const feedback = document.getElementById("feedback");

          // Disable all options
          options.forEach((option) => (option.disabled = true));

          // Show correct/incorrect styling
          options.forEach((option, index) => {
            if (index === question.correct) {
              option.classList.add("correct");
            } else if (index === selectedIndex && index !== question.correct) {
              option.classList.add("incorrect");
            }
          });

          // Show feedback
          if (selectedIndex === question.correct) {
            feedback.textContent = "Correct! Well done!";
            feedback.className = "correct";
            this.score++;
          } else {
            feedback.textContent = `Incorrect. The correct answer was: ${
              question.options[question.correct]
            }`;
            feedback.className = "incorrect";
          }

          feedback.style.display = "block";
          document.getElementById("continueBtn").style.display = "block";

          // Mark question as answered
          this.answeredQuestions.add(this.currentQuestionIndex);
          this.updateScore();
          this.updateGameStats();
        }

        closeQuestionModal() {
          document.getElementById("questionModal").style.display = "none";
          this.draw(); // Redraw to remove the question point
        }

        showNameModal() {
          document.getElementById("finalScore").textContent = this.score;
          document.getElementById("finalTime").textContent = this.formatTime(
            this.gameTime
          );
          document.getElementById("nameInput").value = "";
          document.getElementById("nameModal").style.display = "block";
          document.getElementById("nameInput").focus();
        }

        submitScore() {
          const name = document.getElementById("nameInput").value.trim();
          if (!name) {
            alert("Please enter your name!");
            return;
          }

          const scoreData = {
            name: name,
            score: this.score,
            time: this.gameTime,
            date: new Date().toISOString(),
          };

          this.saveScore(scoreData);
          document.getElementById("nameModal").style.display = "none";
          this.loadLeaderboard();
        }

        saveScore(scoreData) {
          let leaderboard = JSON.parse(
            localStorage.getItem("mazeGameLeaderboard") || "[]"
          );
          leaderboard.push(scoreData);

          // Sort by score (descending) then by time (ascending)
          leaderboard.sort((a, b) => {
            if (b.score !== a.score) {
              return b.score - a.score;
            }
            return a.time - b.time;
          });

          // Keep only top 10 scores
          leaderboard = leaderboard.slice(0, 10);

          localStorage.setItem(
            "mazeGameLeaderboard",
            JSON.stringify(leaderboard)
          );
        }

        loadLeaderboard() {
          const leaderboard = JSON.parse(
            localStorage.getItem("mazeGameLeaderboard") || "[]"
          );
          const leaderboardList = document.getElementById("leaderboardList");

          if (leaderboard.length === 0) {
            leaderboardList.innerHTML =
              '<div style="text-align: center; color: #666; font-style: italic;">No scores yet!</div>';
            return;
          }

          leaderboardList.innerHTML = leaderboard
            .map((entry, index) => {
              const isTopScore = index === 0;
              return `
                        <div class="leaderboard-entry ${
                          isTopScore ? "top-score" : ""
                        }">
                            <span class="rank">#${index + 1}</span>
                            <span class="name">${entry.name}</span>
                            <span class="score">${entry.score}/5</span>
                            <span class="time">${this.formatTime(
                              entry.time
                            )}</span>
                        </div>
                    `;
            })
            .join("");
        }

        formatTime(milliseconds) {
          const seconds = Math.floor(milliseconds / 1000);
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;
          return `${minutes.toString().padStart(2, "0")}:${remainingSeconds
            .toString()
            .padStart(2, "0")}`;
        }

        updateScore() {
          document.getElementById(
            "score"
          ).textContent = `Questions Answered: ${this.score}`;
        }

        updateGameStats() {
          document.getElementById("gameTime").textContent = this.formatTime(
            this.gameTime
          );
          document.getElementById("questionsRemaining").textContent =
            this.questionPoints.length - this.answeredQuestions.size;
        }

        draw() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw maze
          this.ctx.fillStyle = this.colors.mazeWalls;
          for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
              if (this.maze[y][x] === 1) {
                this.ctx.fillRect(
                  x * this.cellSize,
                  y * this.cellSize,
                  this.cellSize,
                  this.cellSize
                );
              }
            }
          }

          // Draw start point (green square)
          this.ctx.fillStyle = this.colors.startPoint;
          this.ctx.fillRect(
            1 * this.cellSize + 2,
            1 * this.cellSize + 2,
            this.cellSize - 4,
            this.cellSize - 4
          );

          // Draw "START" text
          this.ctx.fillStyle = "#000";
          this.ctx.font = "10px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            "START",
            1.5 * this.cellSize,
            1.5 * this.cellSize + 3
          );

          // Draw end point (red square)
          const endGridX = this.cols - 2;
          const endGridY = this.rows - 2;
          this.ctx.fillStyle = this.colors.endPoint;
          this.ctx.fillRect(
            endGridX * this.cellSize + 2,
            endGridY * this.cellSize + 2,
            this.cellSize - 4,
            this.cellSize - 4
          );

          // Draw "END" text
          this.ctx.fillStyle = "#fff";
          this.ctx.font = "10px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            "END",
            (endGridX + 0.5) * this.cellSize,
            (endGridY + 0.5) * this.cellSize + 3
          );

          // Draw question points (only unanswered ones)
          this.ctx.fillStyle = this.colors.questionPoints;
          this.questionPoints.forEach((point, index) => {
            if (!this.answeredQuestions.has(index)) {
              this.ctx.beginPath();
              this.ctx.arc(point.x, point.y, this.cellSize / 3, 0, 2 * Math.PI);
              this.ctx.fill();
            }
          });

          // Draw player (blue dot) using smooth pixel coordinates
          this.ctx.fillStyle = this.colors.player;
          this.ctx.beginPath();
          this.ctx.arc(
            this.player.x,
            this.player.y,
            this.playerRadius,
            0,
            2 * Math.PI
          );
          this.ctx.fill();
        }
      }

      // Start the game when page loads
      window.addEventListener("load", () => {
        new MazeGame();
      });
    </script>
  </body>
</html>
